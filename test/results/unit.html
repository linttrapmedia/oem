<html>
    <head>
      <title>OEM Element Unit Tests</title>
      <script>// src/HTML.ts
function CreateEl(tag, config) {
  return (...props) => {
    const ns = "http://www.w3.org/1999/xhtml";
    const el = document.createElementNS(ns, tag);
    return HtmlTag(el, props, config);
  };
}
function HtmlTag(el, traits = [], config = {}) {
  traits.forEach(([trait, ...args]) => config[trait](el, ...args));
  function fn(...children) {
    children.forEach((child) => {
      if (child)
        el.append(child);
    });
    return el;
  }
  return fn;
}
function HTML(config) {
  return new Proxy({}, {
    get: (_, prop) => CreateEl(prop, config)
  });
}

// src/Trait.ts
function Trait(traitFn) {
  return (...traitProps) => {
    const el = traitProps[0];
    const cleanupFunc = traitFn(...traitProps);
    let observer = null;
    const fullCleanup = () => {
      if (typeof cleanupFunc === "function") {
        cleanupFunc();
      }
      if (observer) {
        observer.disconnect();
        observer = null;
      }
    };
    if (el.parentNode) {
      observer = new MutationObserver((mutationsList) => {
        for (const mutation of mutationsList) {
          if (mutation.type === "childList") {
            if (Array.from(mutation.removedNodes).includes(el)) {
              fullCleanup();
              return;
            }
          }
        }
      });
      observer.observe(el.parentNode, { childList: true });
    }
    return fullCleanup;
  };
}

// src/lib/traits/Attribute.ts
var useAttributeTrait = Trait((...props) => {
  const [el, prop, val, condition = true, ...states] = props;
  const apply = () => {
    const _val = typeof val === "function" ? val() : val;
    const _condition = typeof condition === "function" ? condition() : condition;
    if (_condition) {
      if (_val === undefined) {
        el.removeAttribute(prop);
      } else {
        el.setAttribute(prop, String(_val));
      }
    } else {
      el.removeAttribute(prop);
    }
  };
  apply();
  const unsubs = states.map((state) => state.sub(apply));
  return () => unsubs.forEach((unsub) => unsub());
});

// src/lib/traits/TextContent.ts
var useTextContentTrait = Trait((...props) => {
  const [el, children, condition, ...states] = props;
  const apply = () => {
    const _children = typeof children === "function" ? children() : children;
    const _condition = typeof condition === "function" ? condition() : condition ?? true;
    if (_condition) {
      el.textContent = String(_children);
    }
  };
  apply();
  const unsubs = states.map((state) => state.sub(apply));
  return () => unsubs.forEach((unsub) => unsub());
});

// node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
var MapShim = function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex(arr, key) {
    var result = -1;
    arr.some(function(entry, index) {
      if (entry[0] === key) {
        result = index;
        return true;
      }
      return false;
    });
    return result;
  }
  return function() {
    function class_1() {
      this.__entries__ = [];
    }
    Object.defineProperty(class_1.prototype, "size", {
      get: function() {
        return this.__entries__.length;
      },
      enumerable: true,
      configurable: true
    });
    class_1.prototype.get = function(key) {
      var index = getIndex(this.__entries__, key);
      var entry = this.__entries__[index];
      return entry && entry[1];
    };
    class_1.prototype.set = function(key, value) {
      var index = getIndex(this.__entries__, key);
      if (~index) {
        this.__entries__[index][1] = value;
      } else {
        this.__entries__.push([key, value]);
      }
    };
    class_1.prototype.delete = function(key) {
      var entries = this.__entries__;
      var index = getIndex(entries, key);
      if (~index) {
        entries.splice(index, 1);
      }
    };
    class_1.prototype.has = function(key) {
      return !!~getIndex(this.__entries__, key);
    };
    class_1.prototype.clear = function() {
      this.__entries__.splice(0);
    };
    class_1.prototype.forEach = function(callback, ctx) {
      if (ctx === undefined) {
        ctx = null;
      }
      for (var _i = 0, _a = this.__entries__;_i < _a.length; _i++) {
        var entry = _a[_i];
        callback.call(ctx, entry[1], entry[0]);
      }
    };
    return class_1;
  }();
}();
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
}();
var requestAnimationFrame$1 = function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1000 / 60);
  };
}();
var trailingTimeout = 2;
function throttle(callback, delay) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  return proxy;
}
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = function() {
  function ResizeObserverController2() {
    this.connected_ = false;
    this.mutationEventsAdded_ = false;
    this.mutationsObserver_ = null;
    this.observers_ = [];
    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
  }
  ResizeObserverController2.prototype.addObserver = function(observer) {
    if (!~this.observers_.indexOf(observer)) {
      this.observers_.push(observer);
    }
    if (!this.connected_) {
      this.connect_();
    }
  };
  ResizeObserverController2.prototype.removeObserver = function(observer) {
    var observers = this.observers_;
    var index = observers.indexOf(observer);
    if (~index) {
      observers.splice(index, 1);
    }
    if (!observers.length && this.connected_) {
      this.disconnect_();
    }
  };
  ResizeObserverController2.prototype.refresh = function() {
    var changesDetected = this.updateObservers_();
    if (changesDetected) {
      this.refresh();
    }
  };
  ResizeObserverController2.prototype.updateObservers_ = function() {
    var activeObservers = this.observers_.filter(function(observer) {
      return observer.gatherActive(), observer.hasActive();
    });
    activeObservers.forEach(function(observer) {
      return observer.broadcastActive();
    });
    return activeObservers.length > 0;
  };
  ResizeObserverController2.prototype.connect_ = function() {
    if (!isBrowser || this.connected_) {
      return;
    }
    document.addEventListener("transitionend", this.onTransitionEnd_);
    window.addEventListener("resize", this.refresh);
    if (mutationObserverSupported) {
      this.mutationsObserver_ = new MutationObserver(this.refresh);
      this.mutationsObserver_.observe(document, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      });
    } else {
      document.addEventListener("DOMSubtreeModified", this.refresh);
      this.mutationEventsAdded_ = true;
    }
    this.connected_ = true;
  };
  ResizeObserverController2.prototype.disconnect_ = function() {
    if (!isBrowser || !this.connected_) {
      return;
    }
    document.removeEventListener("transitionend", this.onTransitionEnd_);
    window.removeEventListener("resize", this.refresh);
    if (this.mutationsObserver_) {
      this.mutationsObserver_.disconnect();
    }
    if (this.mutationEventsAdded_) {
      document.removeEventListener("DOMSubtreeModified", this.refresh);
    }
    this.mutationsObserver_ = null;
    this.mutationEventsAdded_ = false;
    this.connected_ = false;
  };
  ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
    var _b = _a.propertyName, propertyName = _b === undefined ? "" : _b;
    var isReflowProperty = transitionKeys.some(function(key) {
      return !!~propertyName.indexOf(key);
    });
    if (isReflowProperty) {
      this.refresh();
    }
  };
  ResizeObserverController2.getInstance = function() {
    if (!this.instance_) {
      this.instance_ = new ResizeObserverController2;
    }
    return this.instance_;
  };
  ResizeObserverController2.instance_ = null;
  return ResizeObserverController2;
}();
var defineConfigurable = function(target, props) {
  for (var _i = 0, _a = Object.keys(props);_i < _a.length; _i++) {
    var key = _a[_i];
    Object.defineProperty(target, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target;
};
var getWindowOf = function(target) {
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  return ownerGlobal || global$1;
};
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value) {
  return parseFloat(value) || 0;
}
function getBordersSize(styles) {
  var positions = [];
  for (var _i = 1;_i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function(size, position) {
    var value = styles["border-" + position + "-width"];
    return size + toFloat(value);
  }, 0);
}
function getPaddings(styles) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i = 0, positions_1 = positions;_i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value = styles["padding-" + position];
    paddings[position] = toFloat(value);
  }
  return paddings;
}
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target) {
  var { clientWidth, clientHeight } = target;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles.width), height = toFloat(styles.height);
  if (styles.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
var isSVGGraphicsElement = function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  }
  return function(target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
  };
}();
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
function createReadOnlyRect(_a) {
  var { x, y, width, height } = _a;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x,
    y,
    width,
    height,
    top: y,
    right: x + width,
    bottom: height + y,
    left: x
  });
  return rect;
}
function createRectInit(x, y, width, height) {
  return { x, y, width, height };
}
var ResizeObservation = function() {
  function ResizeObservation2(target) {
    this.broadcastWidth = 0;
    this.broadcastHeight = 0;
    this.contentRect_ = createRectInit(0, 0, 0, 0);
    this.target = target;
  }
  ResizeObservation2.prototype.isActive = function() {
    var rect = getContentRect(this.target);
    this.contentRect_ = rect;
    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
  };
  ResizeObservation2.prototype.broadcastRect = function() {
    var rect = this.contentRect_;
    this.broadcastWidth = rect.width;
    this.broadcastHeight = rect.height;
    return rect;
  };
  return ResizeObservation2;
}();
var ResizeObserverEntry = function() {
  function ResizeObserverEntry2(target, rectInit) {
    var contentRect = createReadOnlyRect(rectInit);
    defineConfigurable(this, { target, contentRect });
  }
  return ResizeObserverEntry2;
}();
var ResizeObserverSPI = function() {
  function ResizeObserverSPI2(callback, controller, callbackCtx) {
    this.activeObservations_ = [];
    this.observations_ = new MapShim;
    if (typeof callback !== "function") {
      throw new TypeError("The callback provided as parameter 1 is not a function.");
    }
    this.callback_ = callback;
    this.controller_ = controller;
    this.callbackCtx_ = callbackCtx;
  }
  ResizeObserverSPI2.prototype.observe = function(target) {
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    if (typeof Element === "undefined" || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    if (observations.has(target)) {
      return;
    }
    observations.set(target, new ResizeObservation(target));
    this.controller_.addObserver(this);
    this.controller_.refresh();
  };
  ResizeObserverSPI2.prototype.unobserve = function(target) {
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    if (typeof Element === "undefined" || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    if (!observations.has(target)) {
      return;
    }
    observations.delete(target);
    if (!observations.size) {
      this.controller_.removeObserver(this);
    }
  };
  ResizeObserverSPI2.prototype.disconnect = function() {
    this.clearActive();
    this.observations_.clear();
    this.controller_.removeObserver(this);
  };
  ResizeObserverSPI2.prototype.gatherActive = function() {
    var _this = this;
    this.clearActive();
    this.observations_.forEach(function(observation) {
      if (observation.isActive()) {
        _this.activeObservations_.push(observation);
      }
    });
  };
  ResizeObserverSPI2.prototype.broadcastActive = function() {
    if (!this.hasActive()) {
      return;
    }
    var ctx = this.callbackCtx_;
    var entries = this.activeObservations_.map(function(observation) {
      return new ResizeObserverEntry(observation.target, observation.broadcastRect());
    });
    this.callback_.call(ctx, entries, ctx);
    this.clearActive();
  };
  ResizeObserverSPI2.prototype.clearActive = function() {
    this.activeObservations_.splice(0);
  };
  ResizeObserverSPI2.prototype.hasActive = function() {
    return this.activeObservations_.length > 0;
  };
  return ResizeObserverSPI2;
}();
var observers = typeof WeakMap !== "undefined" ? new WeakMap : new MapShim;
var ResizeObserver = function() {
  function ResizeObserver2(callback) {
    if (!(this instanceof ResizeObserver2)) {
      throw new TypeError("Cannot call a class as a function.");
    }
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    var controller = ResizeObserverController.getInstance();
    var observer = new ResizeObserverSPI(callback, controller, this);
    observers.set(this, observer);
  }
  return ResizeObserver2;
}();
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(method) {
  ResizeObserver.prototype[method] = function() {
    var _a;
    return (_a = observers.get(this))[method].apply(_a, arguments);
  };
});
var index = function() {
  if (typeof global$1.ResizeObserver !== "undefined") {
    return global$1.ResizeObserver;
  }
  return ResizeObserver;
}();
var ResizeObserver_es_default = index;

// src/HTML.test.ts
globalThis.ResizeObserver = ResizeObserver_es_default;
var CanApplyMultipleTraitsToHtml = () => {
  const { div } = HTML({
    attr: useAttributeTrait,
    text: useTextContentTrait
  });
  const e1 = div(["attr", "id", "test"], ["text", "test"])();
  const t1 = e1.outerHTML === '<div id="test">test</div>';
  return { pass: t1 };
};
var CanCreateBasicHtmlTagWithText = () => {
  const { div } = HTML();
  const test = div()("test");
  const t1 = test.outerHTML === "<div>test</div>";
  return { pass: t1 };
};
var HasValidHtmlNamespace = () => {
  const { div } = HTML({
    attr: useAttributeTrait
  });
  const t1 = div(["attr", "id", "1"])().namespaceURI === "http://www.w3.org/1999/xhtml";
  return { pass: t1 };
};

// src/State.ts
function getPersistedVal(param, persistence) {
  if (!persistence)
    return param;
  const storageParam = persistence.storage.getItem(persistence.key);
  const parsedStorageParam = JSON.parse(storageParam);
  const isStorageParamValid = parsedStorageParam !== null && parsedStorageParam !== undefined;
  if ((persistence.overwrite ?? true) && isStorageParamValid)
    return parsedStorageParam;
  if (!(persistence.overwrite ?? true) && isStorageParamValid) {
    if (Array.isArray(param) && Array.isArray(parsedStorageParam)) {
      return [...param, ...parsedStorageParam];
    } else if (typeof param === "object" && typeof parsedStorageParam === "object") {
      return { ...param, ...parsedStorageParam };
    }
  }
  return param;
}
function State(param, persistence) {
  let _val = getPersistedVal(param, persistence);
  const _subs = new Set;
  const val = () => _val;
  const _set = (atom) => {
    _val = atom;
    _subs.forEach((i) => i(atom));
    if (persistence)
      persistence.storage.setItem(persistence.key, JSON.stringify(atom));
  };
  const $set = (atom) => () => _set(atom);
  const reduce = (cb) => _set(cb(_val));
  const $reduce = (cb) => () => _set(cb(val()));
  const _sub = (cb) => {
    _subs.add(cb);
    return () => _unsub(cb);
  };
  const test = (predicate, truthCheck = true) => {
    const serialized_currentVal = JSON.stringify(_val);
    if (predicate instanceof RegExp) {
      const result = predicate.test(serialized_currentVal);
      return truthCheck ? result : !result;
    } else if (typeof predicate === "function" && predicate instanceof Function) {
      const result = predicate(_val);
      return truthCheck ? result : !result;
    } else {
      const string_comparison = JSON.stringify(predicate);
      const result = serialized_currentVal === string_comparison;
      return truthCheck ? result : !result;
    }
  };
  const $test = (predicate, truthCheck = true) => () => {
    const serialized_currentVal = JSON.stringify(_val);
    if (predicate instanceof RegExp) {
      const result = predicate.test(serialized_currentVal);
      return truthCheck ? result : !result;
    } else if (typeof predicate === "function" && predicate instanceof Function) {
      const result = predicate(_val);
      return truthCheck ? result : !result;
    } else {
      const string_comparison = JSON.stringify(predicate);
      const result = serialized_currentVal === string_comparison;
      return truthCheck ? result : !result;
    }
  };
  const _unsub = (cb) => {
    _subs.delete(cb);
  };
  return {
    reduce,
    set: _set,
    sub: _sub,
    test,
    unsub: _unsub,
    val,
    $reduce,
    $set,
    $test
  };
}

// src/lib/states/MediaQuery.ts
var useMediaQueryState = (props) => {
  const { type = "all", minWidth = 0, maxWidth = Infinity } = props;
  const state = State(false);
  const apply = () => {
    const width = window.innerWidth;
    const mediaMatches = width >= minWidth && width <= maxWidth;
    const typeMatches = type === "all" || window.matchMedia(type).matches;
    state.set(mediaMatches && typeMatches);
  };
  apply();
  window.addEventListener("resize", apply);
  return state;
};

// src/lib/states/MediaQuery.test.ts
if (!window.matchMedia) {
  window.matchMedia = function(query) {
    return {
      matches: true,
      media: query,
      onchange: null,
      addListener: function() {},
      removeListener: function() {},
      addEventListener: function() {},
      removeEventListener: function() {},
      dispatchEvent: function() {
        return false;
      }
    };
  };
}
var CanKeepTrackOfMediaQueryState = () => {
  Object.defineProperty(window, "innerWidth", { writable: true, configurable: true, value: 1024 });
  const mq1 = useMediaQueryState({
    type: "screen",
    minWidth: 500,
    maxWidth: 2000
  });
  const t1 = mq1.val() === true;
  const mq2 = useMediaQueryState({
    type: "screen",
    minWidth: 1400,
    maxWidth: 2000
  });
  const t2 = mq2.val() === false;
  const tests = [t1, t2];
  return { pass: tests.every(Boolean) };
};

// src/SVG.ts
function SvgTag(el, traits = [], config = {}) {
  traits.forEach(([trait, ...args]) => config[trait](el, ...args));
  function fn(...children) {
    children.forEach((child) => el.append(child));
    return el;
  }
  return fn;
}
function SVG(config) {
  return new Proxy({}, {
    get: (_, prop) => {
      if (prop === "el")
        return (el) => (...props) => SvgTag(el, props, config);
      return (...props) => {
        const ns = "http://www.w3.org/2000/svg";
        const el = document.createElementNS(ns, prop);
        return SvgTag(el, props, config);
      };
    }
  });
}

// src/lib/traits/Attribute.test.ts
var CanApplyAttributeTraitToHtml = () => {
  const disabled = State(false);
  const { div } = HTML({
    staticAttr: useAttributeTrait,
    dynamicAttr: useAttributeTrait
  });
  const e1 = div(["staticAttr", "id", "test"])();
  const t1 = e1.outerHTML === '<div id="test"></div>';
  const e2 = div(["staticAttr", "disabled", "true"])();
  const t2 = e2.outerHTML === '<div disabled="true"></div>';
  disabled.set(true);
  const e5 = div(["dynamicAttr", "disabled", disabled.val, true, disabled])();
  const t5 = e5.outerHTML === '<div disabled="true"></div>';
  disabled.set(false);
  const e6 = div(["dynamicAttr", "disabled", disabled.val, true, disabled])();
  const t6 = e6.outerHTML === '<div disabled="false"></div>';
  disabled.set(true);
  const e7 = div(["dynamicAttr", "disabled", "true", disabled.val])();
  const t7 = e7.outerHTML === '<div disabled="true"></div>';
  disabled.set(false);
  const e8 = div(["dynamicAttr", "disabled", "true", disabled.val])();
  const t8 = e8.outerHTML === "<div></div>";
  return { pass: t1 && t2 && t5 && t6 && t7 && t8 };
};
var CanApplyAttributeTraitToSvg = () => {
  const { circle } = SVG({
    attr: useAttributeTrait
  });
  const e1 = circle(["attr", "id", "test"])();
  const t1 = e1.outerHTML === '<circle id="test"></circle>';
  return { pass: t1 };
};

// src/lib/traits/ClassName.ts
var useClassNameTrait = Trait((...props) => {
  const [el, className, condition = true, ...states] = props;
  const apply = () => {
    const _className = typeof className === "function" ? className() : className;
    const _condition = typeof condition === "function" ? condition() : condition;
    if (_condition)
      el.setAttribute("class", String(_className));
  };
  apply();
  const unsubs = states.map((state) => state.sub(apply));
  return () => unsubs.forEach((unsub) => unsub());
});

// src/lib/traits/ClassName.test.ts
var CanApplyClassNameTraitToHtml = () => {
  const { div } = HTML({
    classname: useClassNameTrait
  });
  const e1 = div(["classname", "c1"], ["classname", "c1"])();
  const t1 = e1.outerHTML === '<div class="c1"></div>';
  const e2 = div(["classname", "c1 c2"])();
  const t2 = e2.outerHTML === '<div class="c1 c2"></div>';
  const e3 = div(["classname", "c1", false])();
  const t3 = e3.outerHTML === "<div></div>";
  const e4 = div(["classname", "c1", true])();
  const t4 = e4.outerHTML === '<div class="c1"></div>';
  const e5 = div(["classname", "c1", () => false])();
  const t5 = e5.outerHTML === "<div></div>";
  const e6 = div(["classname", "c1", () => true])();
  const t6 = e6.outerHTML === '<div class="c1"></div>';
  const e7 = div(["classname", "c1 c2", true], ["classname", "", true])();
  const t7 = e7.outerHTML === '<div class=""></div>';
  return { pass: t1 && t2 && t3 && t4 && t5 && t6 && t7 };
};
var CanApplyClassNameTraitToSvg = () => {
  const { circle } = SVG({ classname: useClassNameTrait });
  const e1 = circle(["classname", "c1"])();
  const t1 = e1.outerHTML === '<circle class="c1"></circle>';
  const e2 = circle(["classname", "c1 c2"])();
  const t2 = e2.outerHTML === '<circle class="c1 c2"></circle>';
  const e3 = circle(["classname", "c1", false])();
  const t3 = e3.outerHTML === "<circle></circle>";
  const e4 = circle(["classname", "c1", true])();
  const t4 = e4.outerHTML === '<circle class="c1"></circle>';
  const e5 = circle(["classname", "c1", () => false])();
  const t5 = e5.outerHTML === "<circle></circle>";
  const e6 = circle(["classname", "c1", () => true])();
  const t6 = e6.outerHTML === '<circle class="c1"></circle>';
  const e7 = circle(["classname", "c1 c2", true], ["classname", "", true])();
  const t7 = e7.outerHTML === '<circle class=""></circle>';
  const tests = [t1, t2, t3, t4, t5, t6, t7];
  return { pass: tests.every(Boolean) };
};

// src/lib/traits/Event.ts
var useEventTrait = Trait((...props) => {
  const [el, evt, cb, condition = true, ...states] = props;
  let listenerAttached = false;
  const apply = () => {
    const _condition = typeof condition === "function" ? condition() : condition;
    if (_condition && !listenerAttached) {
      el.addEventListener(evt, cb);
      listenerAttached = true;
    } else {
      el.removeEventListener(evt, cb);
      listenerAttached = false;
    }
  };
  apply();
  const unsubs = states.map((state) => state.sub(apply));
  return () => {
    el.removeEventListener(evt, cb);
    unsubs.forEach((unsub) => unsub());
  };
});

// src/lib/traits/Event.test.ts
var CanApplyEventListenerTraitToHtml = () => {
  const { div } = HTML({
    event: useEventTrait,
    attr: useAttributeTrait
  });
  let clicked = false;
  const handleClick = () => clicked = true;
  const e1 = div(["event", "clicks", handleClick])();
  e1.click();
  const t1 = clicked;
  return { pass: t1 };
};
var CanConditionallyApplyEventListenerTraitToHtml = () => {
  const toggle = State(true);
  const { div } = HTML({
    event: useEventTrait
  });
  const handleClick = () => toggle.set(!toggle.val());
  const e1 = div(["event", "click", handleClick, false], ["event", "click", handleClick, true])();
  e1.click();
  const t1 = toggle.val() === false;
  e1.click();
  const t2 = toggle.val() === true;
  return { pass: t1 && t2 };
};
var CanApplyEventListenerTraitToSvg = () => {
  const { circle } = SVG({
    event: useEventTrait
  });
  let clicked = false;
  var clickEvent = new MouseEvent("click", {
    view: window,
    bubbles: true,
    cancelable: false
  });
  const handleClick = () => clicked = true;
  const e1 = circle(["event", "click", handleClick])();
  e1.dispatchEvent(clickEvent);
  const t1 = clicked;
  return { pass: t1 };
};
var CanConditionallyApplyEventListenerTraitToSvg = () => {
  const toggle = State(true);
  const { circle } = SVG({
    event: useEventTrait
  });
  const clickEvent = new MouseEvent("click", {
    view: window,
    bubbles: true,
    cancelable: false
  });
  const handleClick = () => toggle.set(!toggle.val());
  const e1 = circle(["event", "click", handleClick, false], ["event", "click", handleClick, true])();
  e1.dispatchEvent(clickEvent);
  const t1 = toggle.val() === false;
  e1.dispatchEvent(clickEvent);
  const t2 = toggle.val() === true;
  return { pass: t1 && t2 };
};

// src/lib/traits/InnerHTML.ts
var useInnerHTMLTrait = Trait((...props) => {
  const [el, children, condition = true, ...states] = props;
  const apply = () => {
    const _children = children();
    const _condition = typeof condition === "function" ? condition() : condition;
    if (_condition) {
      el.innerHTML = "";
      if (_children !== undefined) {
        if (Array.isArray(_children)) {
          _children.filter((c) => c).forEach((c) => {
            if (c instanceof HTMLElement || c instanceof SVGElement)
              el.appendChild(c);
            else
              el.appendChild(document.createTextNode(String(c)));
          });
        } else if (_children instanceof HTMLElement || _children instanceof SVGElement) {
          el.appendChild(_children);
        } else {
          el.innerHTML = String(_children);
        }
      }
    }
  };
  apply();
  const unsubs = states.map((state) => state.sub(apply));
  return () => unsubs.forEach((unsub) => unsub());
});

// src/lib/traits/InnerHTML.test.ts
var CanApplyInnerHTMLTraitToHtml = () => {
  const state = State({ value: "asdf" });
  const { div } = HTML({ html: useInnerHTMLTrait });
  const e1 = div(["html", () => "asdf"])();
  const t1 = e1.outerHTML === "<div>asdf</div>";
  const e2 = div(["html", () => ["one", "two"]])();
  const t2 = e2.outerHTML === "<div>onetwo</div>";
  const e3 = div(["html", () => div()("one")])();
  const t3 = e3.outerHTML === "<div><div>one</div></div>";
  const e4 = div(["html", () => [div()("one"), div()("two")]])();
  const t4 = e4.outerHTML === "<div><div>one</div><div>two</div></div>";
  const e5 = div(["html", () => state.val().value, true, state])();
  const t5 = e5.outerHTML === "<div>asdf</div>";
  state.set({ value: "c1" });
  const e6 = div(["html", () => state.val().value, false, state])();
  const t6 = e6.outerHTML === "<div></div>";
  const e7 = div(["html", () => state.val().value, () => false, state])();
  const t7 = e7.outerHTML === "<div></div>";
  const e8 = div(["html", () => state.val().value, () => true, state])();
  const t8 = e8.outerHTML === "<div>c1</div>";
  state.set({ value: "c2" });
  const e9 = div(["html", () => state.val().value, state.$test(/c2/), state])();
  const t9 = e9.outerHTML === "<div>c2</div>";
  const e10 = div(["html", () => ["one", "two"]], ["html", () => {
    return;
  }, false])();
  const t10 = e10.outerHTML === "<div>onetwo</div>";
  const e11 = div(["html", () => ["one", "two"]], ["html", () => {
    return;
  }, true])();
  const t11 = e11.outerHTML === "<div></div>";
  const tests = [t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11];
  return { pass: tests.every((t) => t) };
};
var CanApplyInnerHTMLTraitToSvg = () => {
  const state = State({ value: "asdf" });
  const { circle } = SVG({ html: useInnerHTMLTrait });
  const e1 = circle(["html", () => "asdf"])();
  const t1 = e1.outerHTML === "<circle>asdf</circle>";
  const e2 = circle(["html", () => ["one", "two"]])();
  const t2 = e2.outerHTML === "<circle>onetwo</circle>";
  const e3 = circle(["html", () => circle()("one")])();
  const t3 = e3.outerHTML === "<circle><circle>one</circle></circle>";
  const e4 = circle(["html", () => [circle()("one"), circle()("two")]])();
  const t4 = e4.outerHTML === "<circle><circle>one</circle><circle>two</circle></circle>";
  const e5 = circle(["html", () => state.val().value, true, state])();
  const t5 = e5.outerHTML === "<circle>asdf</circle>";
  state.set({ value: "c1" });
  const e6 = circle(["html", () => state.val().value, false, state])();
  const t6 = e6.outerHTML === "<circle></circle>";
  const e7 = circle(["html", () => state.val().value, () => false, state])();
  const t7 = e7.outerHTML === "<circle></circle>";
  const e8 = circle(["html", () => state.val().value, () => true, state])();
  const t8 = e8.outerHTML === "<circle>c1</circle>";
  state.set({ value: "c2" });
  const e9 = circle(["html", () => state.val().value, state.$test(/c2/)])();
  const t9 = e9.outerHTML === "<circle>c2</circle>";
  return { pass: t1 && t2 && t3 && t4 && t5 && t6 && t7 && t8 && t9 };
};

// src/lib/traits/Map.ts
var useMapTraitTrait = Trait((...props) => {
  const [el, items, renderer, condition = true, ...states] = props;
  const apply = () => {
    const cond = typeof condition === "function" ? condition() : condition;
    if (!cond)
      return;
    items().forEach((item, index2) => {
      const itemEl = renderer(item, index2);
      const itemKey = itemEl.getAttribute("key");
      if (!itemKey)
        throw new Error('Each item must have a unique "key" property for mapping.');
      const currEl = el.querySelector(`[key="${itemKey}"]`);
      const isDiff = itemEl.outerHTML !== currEl?.outerHTML;
      if (!currEl)
        return el.appendChild(itemEl);
      if (currEl && isDiff)
        el.replaceChild(itemEl, currEl);
    });
  };
  apply();
  const unsubs = states.map((state) => state.sub(apply));
  return () => unsubs.forEach((unsub) => unsub());
});

// src/lib/traits/Map.test.ts
var CanMapListOfElements = () => {
  const items1 = State(["item1", "item2"]);
  const tmpl1 = HTML({
    map: useMapTraitTrait,
    attr: useAttributeTrait
  });
  const render1 = (item) => tmpl1.div(["attr", "key", item])(item);
  const e1 = tmpl1.div(["map", items1.val, render1, true, items1])();
  const t1 = e1.outerHTML === '<div><div key="item1">item1</div><div key="item2">item2</div></div>';
  const items2 = State(["item1", "item2"]);
  const tmpl2 = HTML({
    map: useMapTraitTrait,
    attr: useAttributeTrait
  });
  const render2 = (item) => tmpl2.div(["attr", "key", item])(item);
  const e2 = tmpl2.div(["map", items2.val, render2, true, items2])();
  const t2 = e2.outerHTML === '<div><div key="item1">item1</div><div key="item2">item2</div></div>';
  const items3a = State(["item1", "item2"]);
  const items3b = State([1, 2, 10]);
  const tmpl3 = HTML({
    map: useMapTraitTrait,
    attr: useAttributeTrait
  });
  const render3 = (item, i) => tmpl3.div(["attr", "key", i], ["attr", "id", items3b.val()[i]])(item);
  const e3 = tmpl3.div(["map", items3a.val, render3, true, items3b, items3a])();
  items3b.set([3, 4, 10]);
  const t3 = e3.outerHTML === '<div><div key="0" id="3">item1</div><div key="1" id="4">item2</div></div>';
  items3a.reduce((prev) => [...prev, "item3"]);
  const t4 = e3.outerHTML === '<div><div key="0" id="3">item1</div><div key="1" id="4">item2</div><div key="2" id="10">item3</div></div>';
  const tests = [t1, t2, t3, t4];
  return { pass: tests.every(Boolean) };
};

// src/lib/traits/Style.ts
var useStyleTrait = Trait((...props) => {
  const [el, prop, val, condition = true, ...states] = props;
  const apply = () => {
    const _val = typeof val === "function" ? val() : val;
    const _condition = typeof condition === "function" ? condition() : condition;
    if (_condition) {
      prop.startsWith("--") ? el.style.setProperty(prop, _val) : el.style[prop] = _val;
    }
  };
  apply();
  const unsubs = states.map((state) => state.sub(apply));
  return () => unsubs.forEach((unsub) => unsub());
});

// src/lib/traits/Style.test.ts
var CanApplyStyleTraitToHtml = () => {
  const state = State({ fontSize: "13px" });
  const { div } = HTML({ style: useStyleTrait });
  const e1 = div(["style", "fontSize", "12px"])();
  const t1 = e1.outerHTML === '<div style="font-size: 12px;"></div>';
  const e2 = div(["style", "fontSize", () => state.val().fontSize, true, state])();
  const t2a = e2.outerHTML === '<div style="font-size: 13px;"></div>';
  state.set({ fontSize: "14px" });
  const t2b = e2.outerHTML === '<div style="font-size: 14px;"></div>';
  state.set({ fontSize: "15px" });
  const e3 = div(["style", "fontSize", () => state.val().fontSize, () => false, state])();
  const t3 = e3.outerHTML === "<div></div>";
  const e4 = div(["style", "fontSize", () => state.val().fontSize, () => true, state])();
  const t4 = e4.outerHTML === '<div style="font-size: 15px;"></div>';
  const e5 = div(["style", "fontSize", () => state.val().fontSize, state.$test(/15px/), state])();
  const t5 = e5.outerHTML === '<div style="font-size: 15px;"></div>';
  const tests = [t1, t2a, t2b, t3, t4, t5];
  return { pass: tests.every(Boolean) };
};
var CanApplyCssVarWithStyleTraitToHtml = () => {
  const { div } = HTML({ style: useStyleTrait });
  const e1 = div(["style", "--test-var", "testing"])();
  const t1 = e1.outerHTML === '<div style="--test-var: testing;"></div>';
  return { pass: t1 };
};
var CanApplyStyleTraitToSvg = () => {
  const { circle } = SVG({ style: useStyleTrait });
  const e1 = circle(["style", "fontSize", "12px"])();
  const t1 = e1.outerHTML === '<circle style="font-size: 12px;"></circle>';
  const e2 = circle(["style", "fontSize", "12px"], ["style", "color", "red"])();
  const t2 = e2.outerHTML === '<circle style="font-size: 12px; color: red;"></circle>';
  return { pass: t1 && t2 };
};

// src/lib/traits/TextContent.test.ts
var CanApplyTextContentTraitToHtml = () => {
  const state = State({ value: "asdf" });
  const { div } = HTML({
    text: useTextContentTrait
  });
  const e1 = div(["text", "test"])();
  const t1 = e1.outerHTML === "<div>test</div>";
  const e2 = div(["text", () => "test"])();
  const t2 = e2.outerHTML === "<div>test</div>";
  const e3 = div(["text", () => state.val().value, true, state])();
  const t3 = e3.outerHTML === "<div>asdf</div>";
  const e4 = div(["text", () => state.val().value, false, state])();
  const t4 = e4.outerHTML === "<div></div>";
  const e5 = div(["text", () => state.val().value, () => false, state])();
  const t5 = e5.outerHTML === "<div></div>";
  const e6 = div(["text", () => state.val().value, () => true, state])();
  const t6 = e6.outerHTML === "<div>asdf</div>";
  state.set({ value: "c1" });
  const e7 = div(["text", () => state.val().value, () => state.val().value === "c1", state])();
  const t7 = e7.outerHTML === "<div>c1</div>";
  const tests = [t1, t2, t3, t4, t5, t6, t7];
  return { pass: tests.every(Boolean) };
};
var CanApplyTextContentTraitToSvg = () => {
  const { circle } = SVG({
    text: useTextContentTrait
  });
  const e1 = circle(["text", "test"])();
  const t1 = e1.outerHTML === "<circle>test</circle>";
  return { pass: t1 };
};

// src/State.test.ts
var CanCreateState = () => {
  const num = State(1);
  const t1 = num.val() === 1;
  return { pass: t1 };
};
var CanUpdateState = () => {
  const num = State(1);
  num.set(2);
  const t1 = num.val() === 2;
  return { pass: t1 };
};
var CanSubscribeToState = () => {
  const num = State(true);
  let t1 = false;
  num.sub(() => t1 = true);
  num.set(false);
  return { pass: t1 };
};
var CanUnSubscribeToState = () => {
  const num = State(1);
  let t1 = false;
  const cb = () => t1 = !t1;
  num.sub(cb);
  num.set(2);
  num.unsub(cb);
  num.set(3);
  return { pass: t1 };
};
var CanSetStateAndPublish = () => {
  const num = State({
    val: 1
  });
  let flag = false;
  num.sub(() => flag = true);
  num.set({ val: 2 });
  const t1 = flag && num.val().val === 2;
  return { pass: t1 };
};
var CanTestStateValue = () => {
  const num = State(5);
  const str = State("hello");
  const tests = [
    num.test(5),
    num.test(3, false),
    num.$test(5)(),
    num.$test(3, false)(),
    num.test(/5/),
    num.test(/3/, false),
    num.$test(/5/)(),
    num.$test(/3/, false)(),
    str.test("hello"),
    str.test("world", false),
    str.$test("hello")(),
    str.$test("world", false)(),
    str.test(/hello/),
    str.test(/world/, false),
    str.$test(/hello/)(),
    str.$test(/world/, false)(),
    str.test((val) => val === "hello"),
    str.test((val) => val === "world", false),
    str.$test((val) => val === "hello")(),
    str.$test((val) => val === "world", false)()
  ];
  return {
    pass: tests.every((t) => t)
  };
};

// src/SVG.test.ts
var CanApplyMultipleTraitsToSvg = () => {
  const { circle } = SVG({
    attr: useAttributeTrait,
    text: useTextContentTrait
  });
  const e1 = circle(["attr", "id", "test"], ["text", "test"])();
  const t1 = e1.outerHTML === '<circle id="test">test</circle>';
  return { pass: t1 };
};
var CanCreateBasicSvgTagWithText = () => {
  const { circle } = SVG();
  const test = circle()("test");
  const t1 = test.outerHTML === "<circle>test</circle>";
  return { pass: t1 };
};
var HasValidSvgNamespace = () => {
  const { circle } = SVG({
    attr: useAttributeTrait
  });
  const t1 = circle(["attr", "id", "1"])().namespaceURI === "http://www.w3.org/2000/svg";
  return { pass: t1 };
};

// cmd/util/args.ts
var args_default = ["/Users/kevinlint/.bun/bin/bun", "/Users/kevinlint/LintTrap/oem/cmd/test.ts", "FILTER="].slice(2).map((arg) => arg.split("=")).reduce((acc, [key, value]) => ({ ...acc, [key]: value }), {});

// test/runner.ts
function runner(tests) {
  const sandbox = document.querySelector("#test-sandbox");
  const results = document.querySelector("#test-results");
  results.style.display = "grid";
  results.style.columnGap = "10px";
  results.style.rowGap = "2px";
  results.style.gridTemplateColumns = "auto auto auto 1fr";
  tests.forEach(([module, ...assertions]) => {
    assertions.filter((t) => {
      if (args_default.FILTER)
        return t[1].name === args_default.FILTER;
      return true;
    }).forEach(([desc, test]) => {
      let testResult;
      try {
        testResult = test(sandbox);
      } catch (err) {
        testResult = { pass: false, message: err.message };
      }
      const statusEl = document.createElement("div");
      statusEl.style.fontFamily = "monospace";
      statusEl.style.fontSize = "14px";
      statusEl.style.color = testResult.pass ? "green" : "red";
      statusEl.innerText = testResult.pass ? "+" : "x";
      statusEl.className = testResult.pass ? "pass" : "fail";
      const moduleEl = document.createElement("div");
      moduleEl.innerText = module;
      moduleEl.style.color = testResult.pass ? "green" : "red";
      const descEl = document.createElement("div");
      descEl.innerText = desc;
      descEl.style.color = testResult.pass ? "green" : "red";
      const messageEl = document.createElement("div");
      messageEl.innerText = testResult.message || "";
      messageEl.style.color = testResult.pass ? "green" : "red";
      results.append(statusEl, moduleEl, descEl, messageEl);
    });
  });
}

// test/unit.ts
window.addEventListener("DOMContentLoaded", () => {
  runner([
    [
      "HTML",
      ["can apply multiple traits", CanApplyMultipleTraitsToHtml],
      ["can create basic tag with text", CanCreateBasicHtmlTagWithText],
      ["has valid namespace", HasValidHtmlNamespace]
    ],
    [
      "Trait - useAttributeTrait",
      ["can apply attribute trait to html", CanApplyAttributeTraitToHtml],
      ["can apply attribute trait to svg", CanApplyAttributeTraitToSvg]
    ],
    [
      "Trait - useClassName",
      ["can apply class name trait to html", CanApplyClassNameTraitToHtml],
      ["can apply class name trait to svg", CanApplyClassNameTraitToSvg]
    ],
    [
      "Trait - useEventListenerTrait",
      ["can apply event listener trait to html", CanApplyEventListenerTraitToHtml],
      ["can conditionally apply event listener trait to html", CanConditionallyApplyEventListenerTraitToHtml],
      ["can apply event listener trait to svg", CanApplyEventListenerTraitToSvg],
      ["can conditionally apply event listener trait to svg", CanConditionallyApplyEventListenerTraitToSvg]
    ],
    [
      "Trait - useInnerHTMLTrait",
      ["can apply inner html trait to html", CanApplyInnerHTMLTraitToHtml],
      ["can apply inner html trait to svg", CanApplyInnerHTMLTraitToSvg]
    ],
    ["Trait - useMapTrait", ["can map list of elements", CanMapListOfElements]],
    [
      "Trait - useStyleTrait",
      ["can apply style trait to html", CanApplyStyleTraitToHtml],
      ["can apply style trait to svg", CanApplyStyleTraitToSvg],
      ["can apply css var with style trait to html", CanApplyCssVarWithStyleTraitToHtml]
    ],
    [
      "Trait - useTextContentTrait",
      ["can apply text content trait to html", CanApplyTextContentTraitToHtml],
      ["can apply text content trait to svg", CanApplyTextContentTraitToSvg]
    ],
    [
      "SVG",
      ["can apply multiple traits", CanApplyMultipleTraitsToSvg],
      ["can create basic tag with text", CanCreateBasicSvgTagWithText],
      ["has valid namespace", HasValidSvgNamespace]
    ],
    [
      "State",
      ["can create state", CanCreateState],
      ["can update state", CanUpdateState],
      ["can subscribe to state", CanSubscribeToState],
      ["can unsubscribe to state", CanUnSubscribeToState],
      ["can reset state", CanSubscribeToState],
      ["can set state and publish", CanSetStateAndPublish],
      ["can test state value", CanTestStateValue]
    ],
    ["State - useMediaQueryState", ["can create media query state", CanKeepTrackOfMediaQueryState]]
  ]);
});
</script>
    </head>
    <body>
      <div id="test-results"></div>
      <div id="test-sandbox"></div>
    </body>
  </html>